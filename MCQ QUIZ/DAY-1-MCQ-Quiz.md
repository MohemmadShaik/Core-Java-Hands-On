## âœ… Topics Covered (Interview Perspective)

### 1ï¸âƒ£ Java Basics
- **JDK vs JRE vs JVM**
  - JDK â†’ develop
  - JRE â†’ run
  - JVM â†’ execute bytecode
- **Why Java is platform independent**
  - Bytecode + JVM (not because it is interpreted)

### 2ï¸âƒ£ Java Execution Flow
- `.java â†’ .class â†’ JVM`
- Class Loader â†’ Bytecode Verifier â†’ Execution (Interpreter/JIT)

### 3ï¸âƒ£ JVM Architecture (High-Impact)
- **Heap** â†’ Objects
- **Stack** â†’ Local variables & method calls
- **Method Area** â†’ Class metadata & static members
- **Garbage Collector** â†’ Cleans unused heap objects

### 4ï¸âƒ£ Data Types & Variables
- Primitive vs Non-Primitive
- `int` preferred over `Integer` for performance
- **Default values**
  - Instance & static â†’ YES
  - Local â†’ NO (must initialize)

---

## ğŸ§± OOPS Fundamentals

### Encapsulation
- Hides **data**
- Achieved using `private` fields + getters/setters
- Improves security & maintainability

### Abstraction
- Hides **implementation**
- Achieved using interfaces / abstract classes
- Focuses on design & simplicity

ğŸ‘‰ **Key Difference**
- Encapsulation â†’ data security  
- Abstraction â†’ design simplicity

---

## ğŸ§  Interview Takeaways
- Explain JVM in 2 minutes confidently
- Clearly differentiate Encapsulation vs Abstraction
- Avoid common traps (abstract â‰  data hiding)
- Speak with real-time examples (Bank Account, Microservice)

---

## ğŸ“Œ Self-Assessment
- Quiz Score: **4/5**
- Mock Interview Score: **9.5/10**
- Status: **Interview-safe for Java Basics & OOPS**

---

## Key Learnings
- Java source code (.java) is compiled into bytecode (.class) using javac
- JVM executes bytecode, not source code
- Platform independence is achieved through JVM, not OS
- JVM handles memory management and JIT compilation

## MCQ Score
- Day 1 Score: 9/10
- Weak Area: JVM vs Compiler responsibility

### Quiz â€“ Day 1 (27 DEC 2025)
- Topic: Abstraction & Encapsulation
- Score: 15/15
- Confidence: High
- Key clarity: Abstraction reduces complexity, encapsulation controls access

--- 

# Day 01 â€“ Java Basics MCQ Quiz

## Score Summary
- Total Questions: 10
- Correct: 9
- Incorrect: 1
- Accuracy: 90%

---

## Q1. What is the main role of the JVM?

âœ… **Correct Answer:** C  
**Executes bytecode and manages runtime memory**

ğŸ§  **Why?**  
JVM is responsible for executing bytecode, handling memory, garbage collection, and runtime execution.

âŒ **Why others are incorrect?**  
- A: Writing code is developerâ€™s job  
- B: Bytecode is generated by `javac`, not JVM  
- D: Compilation is done before JVM comes into play  

---

## Q2. What is the output generated after compiling a Java program?

âœ… **Correct Answer:** B  
**Bytecode**

ğŸ§  **Why?**  
The Java compiler converts `.java` files into platform-independent `.class` bytecode.

âŒ **Why others are incorrect?**  
- A: JVM creates machine code at runtime  
- C: Java does not expose assembly code  
- D: Java does not generate `.exe` files  

---

## Q3. Which command is used to run a compiled Java program?

âœ… **Correct Answer:** B  
**java ClassName**

ğŸ§  **Why?**  
The `java` command launches the JVM and executes the bytecode.

âŒ **Why others are incorrect?**  
- A: `javac` is only for compilation  
- C: `jvm` is not a valid command  
- D: Invalid syntax  

---

## Q4. Java is platform independent mainly because of:

âœ… **Correct Answer:** C  
**JVM availability on different platforms**

ğŸ§  **Why?**  
Same bytecode runs on any OS that has a JVM.

âŒ **Why others are incorrect?**  
- A: OOP has no relation to platform independence  
- B: Memory management is unrelated  
- D: Performance doesnâ€™t ensure portability  

---

## Q5. Which component performs Just-In-Time (JIT) compilation?

âœ… **Correct Answer:** C  
**JVM**

ğŸ§  **Why?**  
JIT compiler is part of JVM and converts bytecode to native machine code at runtime.

âŒ **Why others are incorrect?**  
- A: JDK is a development kit  
- B: JRE is a package containing JVM  
- D: Java compiler works before execution  

---

## Q6. Which is the correct execution flow of a Java program?

âœ… **Correct Answer:** B  
**.java â†’ .class â†’ JVM**

ğŸ§  **Why?**  
Source code is compiled to bytecode, then executed by JVM.

âŒ **Why others are incorrect?**  
- A, C: Wrong order  
- D: OS does not execute Java source code  

---

## Q7. Which memory area stores class metadata and method definitions?

âœ… **Correct Answer:** C  
**Method Area**

ğŸ§  **Why?**  
Method Area stores class-level information like methods and static data.

âŒ **Why others are incorrect?**  
- A: Heap stores objects  
- B: Stack stores method calls  
- D: Registers are CPU-level  

---

## Q8. What happens when you run `java HelloWorld`?

âœ… **Correct Answer:** B  
**JVM loads bytecode and executes `main()`**

ğŸ§  **Why?**  
JVM loads the class and starts execution from `main()`.

âŒ **Why others are incorrect?**  
- A: Compiler is not invoked  
- C: OS does not run Java source code  
- D: GC runs when required, not first  

---

## Q9. Which statement about Java is TRUE?

âœ… **Correct Answer:** C  
**Java is both compiled and interpreted**

ğŸ§  **Why?**  
Java code is compiled to bytecode and interpreted/executed by JVM with JIT.

âŒ **Why others are incorrect?**  
- A: Java is not only interpreted  
- B: Java fully supports OOP  
- D: JVM is mandatory  

---

## Q10. Why is `main()` declared as static?

âœ… **Correct Answer:** B  
**To allow JVM to call it without creating an object**

ğŸ§  **Why?**  
JVM needs an entry point and cannot depend on object creation.

âŒ **Why others are incorrect?**  
- A: Performance is not the reason  
- C: Inheritance is unrelated  
- D: Garbage collection is independent  

---

## Interview Takeaway (Day 1)
- JVM vs Compiler responsibility is a common interview trap
- Platform independence = JVM, not OS
- Java follows compile + run execution model
